'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/contributing/','title':"Contributing",'content':"Contributing Perlang is at a very early state in its infancy, but do not let this scare you away from contributing anyway. Here are some suggestions:\n  Proof-read this documentation web site. Find out obvious mistakes and submit fixes as GitHub pull requests. There is a convenient \u0026ldquo;Edit this page\u0026rdquo; link at the bottom of each page that simplifies the process of doing simple edits.\n  Download the Perlang source code and try to build it on your local machine. Run the unit tests, to see if they work correctly with your operating system/.NET Core SDK version. If you have ideas for new unit tests, feel free to submit a PR. We are aiming for porting a number of tests from the Lox test suite where applicable, so there is plenty of room here for improvement. (Caveat: we don\u0026rsquo;t support the full feature set from Lox yet, like classes. But there are still many things we do support but which ware lacking unit tests at the moment)\n  File new issues about things that you think Perlang should support. This is especially of interest if you have worked with other programming languages before, that were either lacking some important feature, or included a particular killer feature that you really think we should consider for inclusion in the Perlang code base as well.\n  The GitHub repository structure   https://github.com/perlanghq/perlang-docs - this is the repository for the documentation you are reading right now. The master branch contains the editable content, whereas the gh-pages branch contains the generated web site.\n  https://github.com/perlun/perlang - the source code for the Perlang interpreter\n  "});index.add({'id':1,'href':'/categories/','title':"Categories",'content':""});index.add({'id':2,'href':'/docs/','title':"Docs",'content':""});index.add({'id':3,'href':'/docs/downloads/','title':"Downloads",'content':"Downloads For each commit to the master branch in the Perlang repo, a new snapshot release of the Perlang interpreter is built and published to Bintray.\nHere is the URL: https://bintray.com/perlang/builds/perlang#files. Unfortunately, there is no easy way at the moment to find out what is the \u0026ldquo;latest snapshot\u0026rdquo; apart than looking at the file name (which includes the date \u0026amp; time, as well as the Git SHA-1 \u0026ldquo;object name\u0026rdquo; (i.e. commit ID)).\nSometime in the future, we are aiming to provide something like rustup for Perlang, to make the installation process smoother.\n"});index.add({'id':4,'href':'/','title':"Index",'content':"The Perlang Programming Language Introduction Welcome to the Perlang documentation. In this documentation, we try to describe both what Perlang is and what it aims to become. We try to make the distinction betwen these clear, when relevant.\nThis document is written in a combination of 3rd person and 1st person singular; we tried to stick with the former but didn\u0026rsquo;t succeed completely.\nBackground to how Perlang was born Perlang was conceived in the heart of Per Lundberg around the year 2017-2018, after having worked as a professional programmer for many years, using various languages like Perl, Java, C# and lately, spending a rather large amount of time working with Ruby code. Perhaps a little bit of CoffeeScript and JavaScript there as well.\nSome of these languages felt inherently more pleasant to work with than others. Sometimes, his view of a language was formed not only by facts but also by \u0026ldquo;hearsay\u0026rdquo;; for example, other people complaining about a language being overly verbose (like Java), rather than having spent a great amount of time working with this language lately.\nOf the languages mentioned, Ruby was a language that particularly made Per frustrated and annoyed. If you don\u0026rsquo;t know Ruby from beforehand, it\u0026rsquo;s a dymamically typed scripting language, often used for writing web application backends (with \u0026ldquo;Ruby on Rails\u0026rdquo;, which is an application framework written in Ruby). Ruby definitely has its strengths, and a few years later, Per started to appreciate it much more, perhaps because he was now using it for use cases where it was an even better fit than his previous projects.\nThings I was missing in Ruby Optional typing Ruby is a dynamically typed language, so variables, fields and method parameters are inherently untyped. However, unlike modern languages like TypeScript that provide a way to add an \u0026ldquo;optional\u0026rdquo; type specifier for the variable or parameter, Ruby provides no such mechanism. Why is this a problem?\nWell, it doesn\u0026rsquo;t have to be, depending on whether you are dynamically or statically inclined. But regardless of your personal preferences, types exist. They are real. It\u0026rsquo;s not like they don\u0026rsquo;t exist in a dynamically typed language, it\u0026rsquo;s just that all the type checking has been deferred to a later stage - to runtime.\nFor me, when writing code, I tend to think about what type of objects a method will receive. A simple example to get you going:\ndef do_something(s) s.swapcase end Perhaps I know when writing the code above that the only valid type of parameter for this method is really a String. (Yes, I know that this is the wrong way to think about Ruby code because you should not care about the particular type, instead just that it \u0026ldquo;quacks like a duck\u0026rdquo; and responds to the swapcase message. But there are still cases where you must enforce the type, for example because the data is being converted to JSON (and you don\u0026rsquo;t want the result to be arbitrarily typed), sent to a database (where columns are typically using a fixed data type), etc.)\nWhen I write Ruby code, I\u0026rsquo;m essentially forced to throw away this information in my mind when writing the code. There is absolutely no way to write down in my program\u0026rsquo;s source code what type a given parameter is expected to be of. For me, this is frustrating since it means that in the conversion from a mental model (in my head) to source code, I am essentially forced to remove information. Not redundant information, but actually information that would help the computer run my program in a more efficient way.\nThis leads us naturally to my next point:\nStatic type analysis When a program contains type information, from one of the following sources:\n For all variables/parameters because of explicit typing (i.e. as in traditional, statically typed languages like Java, C# and C++) For all/most variables/parameters because of strong inferred typing (as in languages like F#) For some variables/parameters because of optional typing  \u0026hellip;it can use this information about the typing information to perform static analysis. For example, it can determine that the following Java program is invalid:\nvar s = \u0026#34;Hej hej\u0026#34;; // Produces the following error in JShell 11.0.6: // // cannot find symbol // symbol: method nonExistingMethod() s.nonExistingMethod(); This is because even though s is using an inferred type in this case, the compiler knows that this variable will always contain a String (or null). That way, it can statically determine that the s.nonExistingMethod() method call will always fail. There is simply no way for it to succeed, under any circumstances whatsoever.\nWhy is this important? It is important because typically, it\u0026rsquo;s better if a program fails as early as possible rather than deferring potential failures to runtime checking. We call this the \u0026ldquo;fail fast\u0026rdquo; philosophy.\nAs systems grow in size, this becomes more and more important. Simply put, it gives you an extra level of comfort where you can trust the compiler to find errors in your program. Not all errors unfortunately, but at least a good deal of them.\nWhat if we could extend these concepts further to let the compiler make an even more extensive analysis of the program? This is definitely an area we want to delve further into as we explore what Perlang will become.\nStatic dispatch of methods Ruby uses an extreme form of \u0026ldquo;dynamic dispatch\u0026rdquo; when it comes to calling methods. The following program is completely valid:\ndef foo # Calling a non-existent method bar(123) end puts(\u0026#34;Hello world\u0026#34;) If you save this to a file foo.rb and run ruby foo.rb, the program will run without any errors whatsoever, even though the foo method referenced a method does that does not exist. This is because of how method invocations work in Ruby; all method calls are by definition \u0026ldquo;legal\u0026rdquo;, even when they refer to methods that do not exist. If you call an undefined method, there is even a nice little mechanism called method_missing which lets you define, in any class, a method called method_missing. All calls to non-existing methods will then be delegated to that method. An example:\ndef foo bar(123) end def method_missing(method_name, *args) puts \u0026#34;You called #{method_name}with #{args}\u0026#34; end # (Note: parentheses for method calls are not mandatory in Ruby. The # line below calls the \u0026#34;foo\u0026#34; method defined above.) foo Running the program above yields the following output:\n$ ruby foo.rb You called bar with [123] Nice, huh? This functionality is what powers some of the existing DSL:s written in Ruby, like Sequel.\nI think it\u0026rsquo;s good to have this kind of functionality in the language, but the bad part about it is that there\u0026rsquo;s absolutely no way to \u0026ldquo;turn it off\u0026rdquo; for cases where you would prefer a use strict-mode or similar. I have had cases when there was a typo in a method call or field/variable reference where this was not caught by the unit tests, and I released an updated version of an (internal) Ruby gem - only to realize my folly a bit later.\nIt is my strong conviction that a really good programming language should help you avoid easy mistakes like this.\nConsequences of the above Excessive reliance on unit tests to detect all errors Because of the lack of static analysis of the code (or at least a very weak analysis of it), people in the Ruby camp rely heavily on unit tests for finding software errors. This is not necessarily a bad thing in itself, since unit tests are great and I definitely think the world is better with unit tests than without them, but the thing I don\u0026rsquo;t like is that with Ruby, you are essentially forced to go for at least 100% code coverage to even know that your code is at all remotely working. There are so many small things that can be broken if you ignore this.\nThere is a joke in the industry saying that \u0026ldquo;if it compiles, ship it\u0026rdquo;. Even though this is indeed a joke, there is still a valid point in it. If a computer system compiles, it\u0026rsquo;s not at last fundamentally broken in that methods or classes are being referred to using the wrong name, or silly things like that. The compiler gives you a certain safety net, and I personally find that very valuable. With Perlang, we will strive to make this safety net as comfortable and convenient for you as a developer as possible.\nInferior tooling/IDE support Inferior performance "});index.add({'id':5,'href':'/tags/','title':"Tags",'content':""});})();